#!/bin/bash

NAMESPACE="default"
APP_NAME="nginx-app"
APP_LABEL="app=nginx-app"
BROKEN_IMAGE="nginx:broken-image"
WORKING_IMAGE="nginx:latest"

echo "Injecting broken image into Deployment..."
kubectl set image deployment/$APP_NAME $APP_NAME=$BROKEN_IMAGE -n $NAMESPACE

echo "Waiting for pod to enter ImagePullBackOff / ErrImagePull..."
while true; do
  POD=$(kubectl get pods -n $NAMESPACE -l $APP_LABEL -o jsonpath='{.items[?(@.status.containerStatuses[0].state.waiting.reason)].metadata.name}' 2>/dev/null)
  STATUS=$(kubectl get pod "$POD" -n $NAMESPACE -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' 2>/dev/null)

  if [[ "$STATUS" == "ImagePullBackOff" || "$STATUS" == "ErrImagePull" || "$STATUS" == "CrashLoopBackOff" ]]; then
    echo "Pod $POD failed with status: $STATUS"
    break
  fi
  sleep 2
done

echo "Starting timer for Flux reconciliation..."
START=$(date +%s)

echo "Automatically reverting to the working image..."
kubectl set image deployment/$APP_NAME $APP_NAME=$WORKING_IMAGE -n $NAMESPACE

echo "Deleting broken pod to trigger new pod creation..."
kubectl delete pod "$POD" -n $NAMESPACE

echo "Waiting for a new pod to become Running..."
while true; do
  NEW_POD=$(kubectl get pods -n "$NAMESPACE" -l $APP_LABEL -o jsonpath='{.items[?(@.status.containerStatuses[0].ready==true)].metadata.name}' 2>/dev/null)
  PHASE=$(kubectl get pod "$NEW_POD" -n "$NAMESPACE" -o jsonpath='{.status.phase}' 2>/dev/null)

  if [[ "$PHASE" == "Running" ]]; then
    break
  fi
  sleep 2
done

# Stop timer
END=$(date +%s)
DURATION=$((END - START))

echo "Pod $NEW_POD is back to Running with the correct image: $WORKING_IMAGE âœ…"
echo "FluxCD reconciliation took $DURATION seconds."


